@page "/"

<style>
    canvas {
        cursor: crosshair;
        border: 1px solid #000000;
    }
</style>
<body>
    <BECanvas Width="300" Height="400" @onmousedown="" @ref="_canvasReference"></BECanvas>
    <select id="color">
        <option value="black">Black</option>
        <option value="red">Red</option>
        <option value="yellow">Yellow</option>
        <option value="green">Green</option>
        <option value="blue">Blue</option>
    </select>
    <div id="output"></div>
    @code
    {
        private Canvas2DContext _context;

        protected BECanvasComponent _canvasReference;
        private HubConnection hubConnection;
        private float canvasx;
        private float canvasy;
        private int last_mousex = 0;
        private int last_mousey = 0;
        private int  mousex = 0;
        private int mousey = 0;
        private bool mousedown = false;
        private string tooltype = "draw";

        protected override async Task OnInitializedAsync()
        {

            hubConnection = new HubConnectionBuilder()
                                .WithUrl("http://localhost:55643/draw")
                                .Build();

            hubConnection.On("draw", (int prevX, int prevY, int currentX, int currentY, string color) =>
            {
                drawCanvas(prevX, prevX, currentX, currentY, color).Wait();
                StateHasChanged();
            });

            await hubConnection.StartAsync();
        }

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            this._context = await this._canvasReference.CreateCanvas2DAsync();

            var canvasx = this._context.ShadowOffsetX;
            var canvasy = this._context.ShadowOffsetY;
            var last_mousex = 0;
            var last_mousey = 0;
            var mousex = 0;
            var mousey = 0;
            var mousedown = false;
            var tooltype = "draw";

            await this._context.SetFillStyleAsync("green");

            await this._context.FillRectAsync(10, 100, 100, 100);

            await this._context.SetFontAsync("48px serif");
            await this._context.StrokeTextAsync("Hello Blazor!!!", 10, 100);
        }

        async Task MouseownCanvas()
        {
            last_mousex = mousex = parseInt(e.clientX - canvasx);
            last_mousey = mousey = parseInt(e.clientY - canvasy);
            mousedown = true;
        }

        $(canvas).on('mouseup', function (e) {
            mousedown = false;
        });
        async Task drawCanvas(int prev_x, int prev_y, int x, int y, string clr) {
            await this._context.BeginPathAsync();
            //ctx.globalCompositeOperation = 'source-over';
            await this._context.SetStrokeStyleAsync(clr);
            await this._context.SetLineWidthAsync(3);
            await this._context.MoveToAsync(x, y);
            await this._context.LineToAsync(x, y);
            await this._context.SetLineJoinAsync(LineJoin.Round);
            await this._context.SetLineCapAsync(LineCap.Round);
            await this._context.StrokeAsync();
        }
    }
    @*<script>
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var canvasx = $(canvas).offset().left;
        var canvasy = $(canvas).offset().top;
        var last_mousex = last_mousey = 0;
        var mousex = mousey = 0;
        var mousedown = false;
        var tooltype = 'draw';

        $(canvas).on('mousedown', function (e) {
            last_mousex = mousex = parseInt(e.clientX - canvasx);
            last_mousey = mousey = parseInt(e.clientY - canvasy);
            mousedown = true;
        });

        $(canvas).on('mouseup', function (e) {
            mousedown = false;
        });

        var drawCanvas = function (prev_x, prev_y, x, y, clr) {
            ctx.beginPath();
            console.log("X: " + x + " Y: " + y);
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = clr
            ctx.lineWidth = 3;
            ctx.moveTo(prev_x, prev_y);
            ctx.lineTo(x, y);
            ctx.lineJoin = ctx.lineCap = 'round';
            ctx.stroke();
        };

        $(canvas).on('mousemove', function (e) {
            mousex = parseInt(e.clientX - canvasx);
            mousey = parseInt(e.clientY - canvasy);
            var clr = $('select[id=color]').val()

            if ((last_mousex > 0 && last_mousey > 0) && mousedown) {
                drawCanvas(mousex, mousey, last_mousex, last_mousey, clr);
                connection.invoke('draw', last_mousex, last_mousey, mousex, mousey, clr);
            }
            last_mousex = mousex;
            last_mousey = mousey;

            $('#output').html('current: ' + mousex + ', ' + mousey + '<br/>last: ' + last_mousex + ', ' + last_mousey + '<br/>mousedown: ' + mousedown);
        });

        var mouse_down = false;
        var connection = new signalR.HubConnectionBuilder()
            .withUrl('/draw')
            .build();

        connection.on('draw', function (prev_x, prev_y, x, y, clr) {
            console.log("X: " + x + " Y: " + y);
            drawCanvas(prev_x, prev_y, x, y, clr);
        });
        connection.start();

        clearMousePositions = function () {
            last_mousex = 0;
            last_mousey = 0;
        }

    </script>*@
</body>
